// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

import "@openzeppelin/contracts/access/Ownable.sol";
import "./lib/BrevisAppZkOnly.sol";

// Only accept ZK-attested results.
contract TimeWeightedLiquidity is BrevisAppZkOnly, Ownable {
    event TimeWeightedLiquidityAttested(address account,  uint64 startBlockNum,  uint64 endBlockNum, uint248 liquidity);

    bytes32 public vkHash;

    constructor(address _brevisRequest) BrevisAppZkOnly(_brevisRequest) Ownable(msg.sender) {}

    // BrevisRequest contract will trigger callback once ZK proof is received.
    function handleProofResult(bytes32 _vkHash, bytes calldata _circuitOutput) internal override {
        // We need to check if the verifying key that Brevis used to verify the proof generated by our circuit is indeed
        // our designated verifying key. This proves that the _circuitOutput is authentic
        require(vkHash == _vkHash, "invalid vk");
        (address pool, uint64 startBlockNum, uint64 endBlockNumber, uint248 liquidity) = decodeOutput(_circuitOutput);
        emit TimeWeightedLiquidityAttested(pool, startBlockNum, endBlockNumber, liquidity);
    }

    // In app circuit we have:
    // api.OutputAddress(tx.From)
    // api.OutputUint(64, tx.BlockNum)
    function decodeOutput(bytes calldata o) internal pure returns (address, uint64, uint64, uint248) {
        address pool = address(bytes20(o[0:20])); // pool address
        uint64 startBlockNum = uint64(bytes8(o[20:28])); // start block number as uint64(8 bytes)
        uint64 endBlockNum = uint64(bytes8(o[28:36])); // end block number as uint64(8 bytes)
        uint248 liquidity = uint248(bytes31(o[36:67])); // liquidity was output as a uint248 (31 bytes)

        return (pool, startBlockNum,  endBlockNum, liquidity);
    }

    // vkHash represents the unique circuit app logic
    function setVkHash(bytes32 _vkHash) external onlyOwner {
        vkHash = _vkHash;
    }
}
